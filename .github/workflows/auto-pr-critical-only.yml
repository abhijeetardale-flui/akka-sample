name: Auto PR for CRITICAL Issues ONLY (Highest Priority)

# Creates automated PRs ONLY for CRITICAL severity vulnerabilities
# Use this to address the most urgent security threats first

on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC (critical issues need immediate attention)

permissions:
  contents: write
  pull-requests: write
  security-events: read
  issues: write

jobs:
  critical-only-fixes:
    name: Fix CRITICAL Vulnerabilities (Priority 1)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
      
      - name: Create scan results directory
        run: |
          mkdir -p scan-results
          mkdir -p pr-fixes
      
      # ============================================
      # 1. SCA - Critical Dependencies Only
      # ============================================
      - name: Trivy SCA Scan (CRITICAL ONLY)
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'json'
          output: 'scan-results/trivy-critical.json'
          severity: 'CRITICAL'
          scanners: 'vuln'
      
      - name: OWASP Dependency Check (CRITICAL ONLY)
        continue-on-error: true
        run: |
          echo "üîç Running OWASP Dependency Check for CRITICAL issues..."
          
          # Download OWASP Dependency Check
          wget -q https://github.com/jeremylong/DependencyCheck/releases/download/v9.0.9/dependency-check-9.0.9-release.zip
          unzip -q dependency-check-9.0.9-release.zip
          
          # Run dependency check
          ./dependency-check/bin/dependency-check.sh \
            --scan . \
            --format JSON \
            --out scan-results \
            --prettyPrint \
            --enableExperimental \
            --failOnCVSS 9 \
            || true
          
          echo "‚úÖ OWASP scan complete"
      
      # ============================================
      # 2. Parse and Identify CRITICAL Issues
      # ============================================
      - name: Parse CRITICAL Issues and Generate Fixes
        id: generate_fixes
        run: |
          cat > parse_critical.py << 'PYTHON_SCRIPT'
          import json
          import os
          from collections import defaultdict
          
          def load_json_safe(filepath):
              try:
                  with open(filepath, 'r') as f:
                      return json.load(f)
              except Exception as e:
                  print(f"Could not load {filepath}: {e}")
                  return {}
          
          trivy_data = load_json_safe('scan-results/trivy-critical.json')
          
          critical_issues = []
          fixes_to_apply = []
          
          print("üî¥ PARSING CRITICAL VULNERABILITIES ONLY")
          print("=" * 60)
          
          # Parse Trivy CRITICAL results
          if 'Results' in trivy_data:
              for result in trivy_data.get('Results', []):
                  target = result.get('Target', 'Unknown')
                  print(f"\nüì¶ Scanning: {target}")
                  
                  for vuln in result.get('Vulnerabilities', []):
                      if vuln.get('Severity') == 'CRITICAL':
                          pkg_name = vuln.get('PkgName', 'Unknown')
                          current_version = vuln.get('InstalledVersion', 'Unknown')
                          fixed_version = vuln.get('FixedVersion', '')
                          cve = vuln.get('VulnerabilityID', 'N/A')
                          cvss_score = vuln.get('CVSS', {}).get('nvd', {}).get('V3Score', 'N/A')
                          
                          print(f"  üî¥ CRITICAL: {cve} - {pkg_name} ({current_version})")
                          print(f"     CVSS Score: {cvss_score}")
                          print(f"     Fix: {fixed_version if fixed_version else 'Manual review required'}")
                          
                          issue = {
                              'severity': 'CRITICAL',
                              'cve': cve,
                              'package': pkg_name,
                              'current_version': current_version,
                              'fixed_version': fixed_version,
                              'title': vuln.get('Title', 'No title'),
                              'description': vuln.get('Description', 'No description')[:300],
                              'cvss_score': cvss_score,
                              'references': vuln.get('References', []),
                              'target': target
                          }
                          critical_issues.append(issue)
                          
                          # Generate fix if version available
                          if fixed_version and fixed_version not in ['', 'Not available', 'None']:
                              fixes_to_apply.append({
                                  'package': pkg_name,
                                  'from_version': current_version,
                                  'to_version': fixed_version,
                                  'cve': cve,
                                  'cvss_score': cvss_score
                              })
          
          print("\n" + "=" * 60)
          print(f"‚úÖ Found {len(critical_issues)} CRITICAL vulnerabilities")
          print(f"‚úÖ {len(fixes_to_apply)} can be auto-fixed")
          print("=" * 60)
          
          # Save results
          with open('pr-fixes/critical-issues.json', 'w') as f:
              json.dump(critical_issues, f, indent=2)
          
          with open('pr-fixes/critical-fixes.json', 'w') as f:
              json.dump(fixes_to_apply, f, indent=2)
          
          # Generate detailed summary
          summary_lines = []
          for issue in critical_issues:
              summary_lines.append(f"- {issue['cve']}: {issue['package']} {issue['current_version']} (CVSS: {issue['cvss_score']})")
          
          with open('pr-fixes/critical-summary.txt', 'w') as f:
              f.write('\n'.join(summary_lines))
          
          # Set outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"critical_count={len(critical_issues)}\n")
              f.write(f"fixable_count={len(fixes_to_apply)}\n")
              f.write(f"has_critical={'true' if len(critical_issues) > 0 else 'false'}\n")
          PYTHON_SCRIPT
          
          python3 parse_critical.py
      
      # ============================================
      # 3. Apply Fixes for CRITICAL Issues
      # ============================================
      - name: Apply CRITICAL Fixes
        if: steps.generate_fixes.outputs.has_critical == 'true'
        run: |
          echo "üîß Applying CRITICAL security fixes..."
          
          python3 << 'APPLY_CRITICAL_FIXES'
          import json
          import subprocess
          import re
          
          with open('pr-fixes/critical-fixes.json', 'r') as f:
              fixes = json.load(f)
          
          if not fixes:
              print("‚ÑπÔ∏è No auto-fixable CRITICAL issues found")
              exit(0)
          
          print(f"üîß Applying {len(fixes)} CRITICAL fixes...")
          changes_made = []
          
          for fix in fixes:
              pkg = fix['package']
              from_ver = fix['from_version']
              to_ver = fix['to_version']
              cve = fix['cve']
              
              print(f"\nüî¥ CRITICAL FIX: {cve}")
              print(f"   üì¶ {pkg}: {from_ver} ‚Üí {to_ver}")
              
              # Maven (pom.xml) updates
              pom_files = subprocess.run(['find', '.', '-name', 'pom.xml', '-type', 'f'], 
                                        capture_output=True, text=True).stdout.strip().split('\n')
              
              for pom_file in pom_files:
                  if not pom_file:
                      continue
                  
                  try:
                      with open(pom_file, 'r') as f:
                          content = f.read()
                      
                      original_content = content
                      
                      # Multiple Maven patterns
                      patterns_to_try = [
                          # Property-based version
                          (f'<{pkg}.version>{from_ver}</{pkg}.version>', 
                           f'<{pkg}.version>{to_ver}</{pkg}.version>'),
                          # Direct version in dependency
                          (f'<groupId>{pkg.split(":")[0] if ":" in pkg else pkg}</groupId>\\s*<artifactId>{pkg.split(":")[1] if ":" in pkg else pkg}</artifactId>\\s*<version>{from_ver}</version>',
                           f'<groupId>{pkg.split(":")[0] if ":" in pkg else pkg}</groupId><artifactId>{pkg.split(":")[1] if ":" in pkg else pkg}</artifactId><version>{to_ver}</version>'),
                          # Simple version tag
                          (f'<version>{from_ver}</version>',
                           f'<version>{to_ver}</version>')
                      ]
                      
                      for old_pattern, new_pattern in patterns_to_try:
                          content = re.sub(old_pattern, new_pattern, content, flags=re.MULTILINE)
                      
                      if content != original_content:
                          with open(pom_file, 'w') as f:
                              f.write(content)
                          changes_made.append(f"{cve}: {pkg} in {pom_file}")
                          print(f"   ‚úÖ Updated {pom_file}")
                  except Exception as e:
                      print(f"   ‚ö†Ô∏è Could not update {pom_file}: {e}")
              
              # SBT (build.sbt) updates
              sbt_files = subprocess.run(['find', '.', '-name', 'build.sbt', '-type', 'f'], 
                                        capture_output=True, text=True).stdout.strip().split('\n')
              
              for sbt_file in sbt_files:
                  if not sbt_file:
                      continue
                  
                  try:
                      with open(sbt_file, 'r') as f:
                          content = f.read()
                      
                      original_content = content
                      
                      # SBT patterns - be more aggressive with replacements
                      # Pattern 1: "package" % "artifact" % "version"
                      content = re.sub(
                          rf'("{re.escape(pkg)}"[^"]*%[^"]*")({re.escape(from_ver)})(")',
                          rf'\g<1>{to_ver}\g<3>',
                          content
                      )
                      
                      # Pattern 2: Generic version string replacement for this package
                      lines = content.split('\n')
                      new_lines = []
                      for line in lines:
                          if pkg in line and from_ver in line:
                              line = line.replace(f'"{from_ver}"', f'"{to_ver}"')
                          new_lines.append(line)
                      content = '\n'.join(new_lines)
                      
                      if content != original_content:
                          with open(sbt_file, 'w') as f:
                              f.write(content)
                          changes_made.append(f"{cve}: {pkg} in {sbt_file}")
                          print(f"   ‚úÖ Updated {sbt_file}")
                  except Exception as e:
                      print(f"   ‚ö†Ô∏è Could not update {sbt_file}: {e}")
          
          print(f"\n‚úÖ Applied {len(changes_made)} CRITICAL security fixes")
          if changes_made:
              print("\nChanges applied:")
              for change in changes_made:
                  print(f"  - {change}")
          APPLY_CRITICAL_FIXES
      
      # ============================================
      # 4. Generate PR Content
      # ============================================
      - name: Generate PR Content
        if: steps.generate_fixes.outputs.has_critical == 'true'
        run: |
          cat > generate_pr_content.py << 'EOF'
          import json
          
          with open('pr-fixes/critical-issues.json', 'r') as f:
              issues = json.load(f)
          
          with open('pr-fixes/critical-fixes.json', 'r') as f:
              fixes = json.load(f)
          
          # Generate PR body - using variables to avoid YAML parsing issues
          total = len(issues)
          fixed = len(fixes)
          manual = total - fixed
          
          pr_body = f"# üî¥ URGENT: {total} CRITICAL Security Vulnerabilities\n\n"
          pr_body += "## ‚ö†Ô∏è IMMEDIATE ACTION REQUIRED\n\n"
          pr_body += f"This PR addresses **{total} CRITICAL severity vulnerabilities** (CVSS 9.0+) "
          pr_body += "that pose **immediate security risks** to the application.\n\n"
          pr_body += "---\n\n"
          pr_body += "## üìä Summary\n\n"
          pr_body += "| Metric | Count |\n"
          pr_body += "|--------|-------|\n"
          pr_body += f"| üî¥ **CRITICAL Vulnerabilities** | **{total}** |\n"
          pr_body += f"| ‚úÖ **Auto-fixed** | {fixed} |\n"
          pr_body += f"| ‚ö†Ô∏è **Manual review required** | {manual} |\n\n"
          pr_body += "---\n\n"
          pr_body += "## üî¥ CRITICAL Vulnerabilities Detected\n\n"
          
          for idx, issue in enumerate(issues, 1):
              pr_body += f"\n### {idx}. {issue['cve']}: {issue['title'][:80]}\n\n"
              pr_body += f"**üî¥ CRITICAL - CVSS Score: {issue['cvss_score']}**\n\n"
              pr_body += f"- **Package:** `{issue['package']}`\n"
              pr_body += f"- **Current Version:** `{issue['current_version']}`\n"
              fixed_ver = issue['fixed_version'] if issue['fixed_version'] else 'Manual review required'
              pr_body += f"- **Fixed Version:** `{fixed_ver}`\n"
              pr_body += f"- **Target:** {issue['target']}\n\n"
              pr_body += "**Description:**\n"
              pr_body += f"{issue['description']}\n\n"
              if issue['fixed_version'] and issue['fixed_version'] not in ['', 'Not available', 'None']:
                  pr_body += "**‚úÖ Status:** Automatically fixed in this PR\n\n"
              else:
                  pr_body += "**‚ö†Ô∏è Status:** Manual review and fix required\n\n"
              
              if issue['references']:
                  pr_body += "**References:**\n"
                  for ref in issue['references'][:3]:
                      pr_body += f"- {ref}\n"
                  pr_body += "\n"
              
              pr_body += "---\n\n"
          
          pr_body += "## ‚úÖ Automatic Fixes Applied\n\n"
          pr_body += "This PR automatically updates the following packages to secure versions:\n\n"
          
          if fixes:
              for fix in fixes:
                  pr_body += f"- ‚úÖ **{fix['package']}**: `{fix['from_version']}` ‚Üí `{fix['to_version']}`\n"
                  pr_body += f"  - **CVE:** {fix['cve']}\n"
                  pr_body += f"  - **CVSS:** {fix['cvss_score']}\n\n"
          else:
              pr_body += "_No automatic fixes available. Manual code changes required._\n\n"
          
          pr_body += "---\n\n"
          pr_body += "## üß™ Testing Requirements\n\n"
          pr_body += "**CRITICAL fixes require thorough testing:**\n\n"
          pr_body += "- [ ] All builds pass\n"
          pr_body += "- [ ] All unit tests pass\n"
          pr_body += "- [ ] Integration tests pass\n"
          pr_body += "- [ ] Manual testing of affected components\n"
          pr_body += "- [ ] Security regression testing\n"
          pr_body += "- [ ] Performance impact assessment\n\n"
          pr_body += "---\n\n"
          pr_body += "## ‚ö†Ô∏è Risk Assessment\n\n"
          pr_body += "**These are CRITICAL vulnerabilities:**\n"
          pr_body += "- ‚úÖ Immediate security risk\n"
          pr_body += "- ‚úÖ Potential for data breach\n"
          pr_body += "- ‚úÖ Remote code execution possible\n"
          pr_body += "- ‚úÖ Authentication bypass risk\n"
          pr_body += "- ‚úÖ Privilege escalation possible\n\n"
          pr_body += "**Recommended Action:**\n"
          pr_body += "1. Review this PR immediately\n"
          pr_body += "2. Test thoroughly\n"
          pr_body += "3. **Merge and deploy ASAP**\n\n"
          pr_body += "---\n\n"
          pr_body += "## üìö Additional Information\n\n"
          pr_body += "- **Scan Type:** SCA (Software Composition Analysis)\n"
          pr_body += "- **Severity:** CRITICAL ONLY (CVSS 9.0+)\n"
          pr_body += "- **Auto-Generated:** Yes\n"
          pr_body += "- **Scan Tools:** Trivy, OWASP Dependency Check\n\n"
          pr_body += "---\n\n"
          pr_body += "## üö® Next Steps\n\n"
          pr_body += "1. ‚ö†Ô∏è **URGENT:** Review all changes\n"
          pr_body += "2. ‚úÖ **TEST:** Verify builds and tests pass\n"
          pr_body += "3. üîç **VERIFY:** Check for breaking changes\n"
          pr_body += "4. ‚úÖ **MERGE:** Apply fixes immediately\n"
          pr_body += "5. üöÄ **DEPLOY:** Push to production ASAP\n\n"
          pr_body += "---\n\n"
          pr_body += "*This is an automated CRITICAL security PR. Immediate action is required.*\n"
          pr_body += "*Generated by: Auto PR for CRITICAL Issues workflow*\n"
          
          with open('pr-fixes/pr-body.md', 'w') as f:
              f.write(pr_body)
          
          print("‚úÖ PR content generated")
          EOF
          
          python3 generate_pr_content.py
      
      # ============================================
      # 5. Check for Changes
      # ============================================
      - name: Check for changes
        id: check_changes
        if: steps.generate_fixes.outputs.has_critical == 'true'
        run: |
          if git diff --quiet; then
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No fixable changes to commit"
          else
            echo "changes=true" >> $GITHUB_OUTPUT
            git diff --stat
            echo "‚úÖ Changes detected and ready to commit"
          fi
      
      # ============================================
      # 6. Create Pull Request
      # ============================================
      - name: Create Pull Request
        if: steps.generate_fixes.outputs.has_critical == 'true' && steps.check_changes.outputs.changes == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            üî¥ URGENT: Fix ${{ steps.generate_fixes.outputs.critical_count }} CRITICAL vulnerabilities
            
            Auto-fixed ${{ steps.generate_fixes.outputs.fixable_count }} critical security issues.
            Immediate review and deployment required.
          title: "üî¥ URGENT: Fix ${{ steps.generate_fixes.outputs.critical_count }} CRITICAL Security Vulnerabilities"
          body-path: pr-fixes/pr-body.md
          branch: security/critical-fixes-urgent
          delete-branch: true
          labels: |
            security
            critical
            urgent
            automated-pr
            priority-1
          assignees: abhijeetardale-flui
          reviewers: abhijeetardale-flui
      
      # ============================================
      # 7. Create URGENT Issue
      # ============================================
      - name: Create Urgent Security Issue
        if: steps.generate_fixes.outputs.has_critical == 'true' && steps.check_changes.outputs.changes == 'false'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const issues = JSON.parse(fs.readFileSync('pr-fixes/critical-issues.json', 'utf8'));
            
            let issueBody = `# üî¥ URGENT: ${issues.length} CRITICAL Security Vulnerabilities Detected\n\n`;
            issueBody += `## ‚ö†Ô∏è IMMEDIATE ACTION REQUIRED\n\n`;
            issueBody += `**These vulnerabilities cannot be auto-fixed and require manual code changes.**\n\n`;
            issueBody += `**Risk Level:** CRITICAL (CVSS 9.0+)\n\n`;
            issueBody += `---\n\n`;
            
            issues.forEach((issue, idx) => {
              issueBody += `### ${idx + 1}. ${issue.cve}: ${issue.title}\n\n`;
              issueBody += `**üî¥ CRITICAL - CVSS: ${issue.cvss_score}**\n\n`;
              issueBody += `- **Package:** ${issue.package}\n`;
              issueBody += `- **Current Version:** ${issue.current_version}\n`;
              issueBody += `- **Target:** ${issue.target}\n`;
              issueBody += `- **Description:** ${issue.description}\n\n`;
              issueBody += `---\n\n`;
            });
            
            issueBody += `## üö® Recommended Actions\n\n`;
            issueBody += `1. Review each vulnerability immediately\n`;
            issueBody += `2. Assess impact on application\n`;
            issueBody += `3. Apply manual fixes\n`;
            issueBody += `4. Test thoroughly\n`;
            issueBody += `5. Deploy fixes ASAP\n`;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üî¥ URGENT: ${issues.length} CRITICAL vulnerabilities need immediate attention`,
              body: issueBody,
              labels: ['security', 'critical', 'urgent', 'manual-fix-required']
            });
      
      # ============================================
      # 8. Workflow Summary
      # ============================================
      - name: Generate Summary
        if: always()
        run: |
          echo "## üî¥ CRITICAL Security Vulnerabilities Scan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.generate_fixes.outputs.has_critical }}" == "true" ]; then
            echo "### ‚ö†Ô∏è CRITICAL ISSUES FOUND!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- üî¥ **CRITICAL Vulnerabilities:** ${{ steps.generate_fixes.outputs.critical_count }}" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Auto-fixable:** ${{ steps.generate_fixes.outputs.fixable_count }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ -f pr-fixes/critical-summary.txt ]; then
              echo "### üìã Critical Issues:" >> $GITHUB_STEP_SUMMARY
              cat pr-fixes/critical-summary.txt >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ "${{ steps.check_changes.outputs.changes }}" == "true" ]; then
              echo "### ‚úÖ URGENT PR CREATED!" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "üö® **A CRITICAL security PR has been created.**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**ACTION REQUIRED:**" >> $GITHUB_STEP_SUMMARY
              echo "1. Check the Pull Requests tab IMMEDIATELY" >> $GITHUB_STEP_SUMMARY
              echo "2. Review changes" >> $GITHUB_STEP_SUMMARY
              echo "3. Test thoroughly" >> $GITHUB_STEP_SUMMARY
              echo "4. **MERGE AND DEPLOY ASAP**" >> $GITHUB_STEP_SUMMARY
            else
              echo "### ‚ö†Ô∏è MANUAL FIXES REQUIRED!" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "CRITICAL issues found but no automatic fixes available." >> $GITHUB_STEP_SUMMARY
              echo "**Check the Issues tab for manual fix guidance.**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚úÖ No CRITICAL Vulnerabilities Found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Your application is secure against known CRITICAL threats." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Scan completed at $(date -u)*" >> $GITHUB_STEP_SUMMARY

